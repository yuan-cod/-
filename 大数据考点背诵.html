<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大数据期末复习  </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans SC', sans-serif; background-color: #f8fafc; color: #334155; }
        .answer-box { transition: all 0.3s ease-out; max-height: 0; opacity: 0; overflow: hidden; background-color: #f1f5f9; }
        .answer-box.open { max-height: 2000px; opacity: 1; padding: 1.5rem; } /* 增加高度限制以容纳长内容 */
        .check-circle { transition: all 0.2s; }
        .card-memorized { opacity: 0.6; background-color: #f8fafc; border-color: #e2e8f0; }
        .card-memorized h3 { color: #94a3b8; }
        .tag { font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 0.25rem; font-weight: bold; text-transform: uppercase; white-space: nowrap; }
        .tag-ch1 { background: #eff6ff; color: #1d4ed8; border: 1px solid #dbeafe; } 
        .tag-ch2 { background: #fff7ed; color: #c2410c; border: 1px solid #ffedd5; }
        .tag-ch3 { background: #f0fdf4; color: #15803d; border: 1px solid #dcfce7; } 
        .tag-ch4 { background: #faf5ff; color: #7e22ce; border: 1px solid #f3e8ff; } 
        .tag-ch5 { background: #fef2f2; color: #b91c1c; border: 1px solid #fee2e2; }
        
        /* 表格样式 */
        .content-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; margin-top: 0.5rem; margin-bottom: 0.5rem; background: white; }
        .content-table th, .content-table td { border: 1px solid #cbd5e1; padding: 8px; text-align: left; }
        .content-table th { background-color: #e2e8f0; font-weight: bold; color: #475569; }
        .content-table tr:nth-child(even) { background-color: #f8fafc; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- 顶部固定栏 -->
    <header class="bg-white shadow-md z-20 p-4 sticky top-0">
        <div class="flex justify-between items-center mb-2">
            <div>
                <h1 class="text-xl font-bold text-slate-800">大数据复习 </h1>
                <p class="text-xs text-slate-500">《范围与考点.docx》</p>
            </div>
            <div class="text-right">
                <div class="text-2xl font-bold text-blue-600" id="score">0/40</div>
            </div>
        </div>
        <!-- 进度条 -->
        <div class="w-full bg-slate-200 rounded-full h-2.5">
            <div id="progress" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <!-- 章节筛选 -->
        <div class="flex gap-2 mt-3 overflow-x-auto pb-1 no-scrollbar text-xs font-medium">
            <button onclick="filter('all')" class="px-4 py-1.5 bg-slate-800 text-white rounded-full hover:bg-slate-700 transition">全部</button>
            <button onclick="filter('ch1')" class="px-4 py-1.5 bg-white text-blue-700 border border-blue-200 rounded-full hover:bg-blue-50 transition">第1章</button>
            <button onclick="filter('ch2')" class="px-4 py-1.5 bg-white text-orange-700 border border-orange-200 rounded-full hover:bg-orange-50 transition">第2章</button>
            <button onclick="filter('ch3')" class="px-4 py-1.5 bg-white text-green-700 border border-green-200 rounded-full hover:bg-green-50 transition">第3章</button>
            <button onclick="filter('ch4')" class="px-4 py-1.5 bg-white text-purple-700 border border-purple-200 rounded-full hover:bg-purple-50 transition">第4章</button>
            <button onclick="filter('ch5')" class="px-4 py-1.5 bg-white text-red-700 border border-red-200 rounded-full hover:bg-red-50 transition">第5章</button>
        </div>
    </header>

    <!-- 列表区域 -->
    <main class="flex-1 overflow-y-auto p-4 space-y-4 pb-20 bg-slate-100" id="list">
        <!-- JS 将在这里生成卡片 -->
    </main>

    <!-- 底部控制 -->
    <footer class="bg-white border-t p-3 text-center text-xs text-slate-500 sticky bottom-0 z-20 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
        <div class="flex justify-center gap-6">
            <button onclick="reset()" class="flex items-center gap-1 text-red-500 hover:text-red-700 font-bold transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                重置进度
            </button>
            <button onclick="expandAll()" class="flex items-center gap-1 text-blue-600 hover:text-blue-800 font-bold transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                展开所有答案
            </button>
        </div>
    </footer>

    <script>
        // === 核心考点数据 (完全依据《范围与考点.docx》) ===
        const points = [
            // --- 第1章 ---
            { 
                id: 1, ch: 'ch1', 
                q: "1. 数据的类型 (8、9)", 
                a: `<p class="mb-2 font-bold">按表现形式分：</p>
                    <p class="mb-2">文本、图片、音频、视频；</p>
                    <p class="mb-2 font-bold">按结构分：</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>结构化数据</strong>：数据库存储。</li>
                        <li><strong>半结构化数据</strong>：XML、JSON等。</li>
                        <li><strong>非结构化数据</strong>：占人类数字内容的 <strong>90%</strong>，如视频、音频、图片等。</li>
                    </ul>` 
            },
            { 
                id: 2, ch: 'ch1', 
                q: "2. 数据使用过程 (13)", 
                a: `<p class="mb-2"><strong>三步闭环：</strong></p>
                    <ol class="list-decimal pl-5 space-y-2">
                        <li><strong>数据清洗</strong>：<br>工具：AWK、Python、机器学习库；<br>作用：解决数据缺失、语义模糊。</li>
                        <li><strong>数据管理</strong>：<br>存储于关系型 / NoSQL 数据库。</li>
                        <li><strong>数据分析</strong>：<br>依赖数据挖掘、机器学习；<br>核心技术：MapReduce、Hadoop。</li>
                    </ol>` 
            },
            { 
                id: 3, ch: 'ch1', 
                q: "3. 三次信息化浪潮的标志、解决问题 (33)", 
                a: `<table class="content-table">
                        <thead><tr><th>信息化浪潮</th><th>发生时间</th><th>标志</th><th>解决问题</th><th>代表企业</th></tr></thead>
                        <tbody>
                            <tr><td>第一次浪潮</td><td>1980年前后</td><td>个人计算机</td><td>信息处理</td><td>Intel, AMD, IBM, 微软, 联想</td></tr>
                            <tr><td>第二次浪潮</td><td>1995年前后</td><td>互联网</td><td>信息传输</td><td>雅虎, 谷歌, 阿里, 百度, 腾讯</td></tr>
                            <tr><td>第三次浪潮</td><td>2010年前后</td><td>物联网、云计算和大数据</td><td>信息价值</td><td>(数据驱动型企业)</td></tr>
                        </tbody>
                    </table>` 
            },
            { 
                id: 4, ch: 'ch1', 
                q: "5. 数据产生方式三阶段 (44)", 
                a: `<table class="content-table">
                        <thead><tr><th>阶段</th><th>时间</th><th>产生方式</th><th>数据来源</th></tr></thead>
                        <tbody>
                            <tr><td><strong>运营式系统阶段</strong></td><td>20世纪90年代</td><td>被动</td><td>数据库 (ERPSS/CRM)</td></tr>
                            <tr><td><strong>用户原创内容阶段</strong></td><td>21世纪初 (Web 2.0)</td><td>主动</td><td>博客、微博、微信、社交网络</td></tr>
                            <tr><td><strong>感知式系统阶段</strong></td><td>现在 (IoT)</td><td>自动</td><td>传感器、摄像头、智能手环 (量级最大)</td></tr>
                        </tbody>
                    </table>` 
            },
            { 
                id: 5, ch: 'ch1', 
                q: "6. 大数据的概念（四个特性）及理解 (73/72)", 
                a: `<p class="mb-2 font-bold text-blue-700">大数据的 4V 特征：</p>
                    <ul class="list-disc pl-5 space-y-1 mb-4">
                        <li><strong>Volume (数据量大)</strong>：数据存储量大，计算量大 (TB -> PB -> EB)。</li>
                        <li><strong>Variety (数据类型繁多)</strong>：来源多，格式多 (结构化/非结构化)。</li>
                        <li><strong>Velocity (处理速度快)</strong>：产生快，处理快 (1秒定律，实时分析)。</li>
                        <li><strong class="text-red-600">Value (价值密度低)</strong>：核心特征。数据总量大，但有价值的信息少 ("浪里淘沙")。</li>
                    </ul>
                    <p class="mb-2 font-bold text-blue-700">对大数据的理解：</p>
                    <p>大数据是“未来的石油”，是一种资本。它的价值不因使用而削减，反而通过重组、分析释放更多价值。</p>` 
            },

            // --- 第2章 ---
            { 
                id: 6, ch: 'ch2', 
                q: "7. 云计算的优点 & 服务模式 & 类型 (14/16-18)", 
                a: `<p class="font-bold mt-2">云计算的优势：</p>
                    <ul class="list-disc pl-5 mb-3">
                        <li>按需服务，即买即用。</li>
                        <li>随时随地，通过网络访问。</li>
                        <li>弹性扩展，支持大规模用户。</li>
                        <li>经济划算，前期零投入，后期免维护。</li>
                    </ul>
                    <p class="font-bold mt-2">云计算的三种服务模式：</p>
                    <ul class="list-disc pl-5 mb-3">
                        <li><strong>IaaS</strong> (基础设施即服务)：出租计算、存储、网络 (如买服务器)。</li>
                        <li><strong>PaaS</strong> (平台即服务)：出租开发/运行环境 (如买数据库服务)。</li>
                        <li><strong>SaaS</strong> (软件即服务)：出租应用程序 (如直接用网盘)。</li>
                    </ul>
                    <p class="font-bold mt-2">云计算的三种类型：</p>
                    <p class="pl-5">公有云、私有云、混合云。</p>` 
            },
            { 
                id: 7, ch: 'ch2', 
                q: "8. 大数据与云计算、物联网的关系 (63)", 
                a: `<div class="p-3 bg-blue-50 rounded border border-blue-100">
                        <p class="mb-2"><strong>物联网</strong>：是数据的<strong>来源</strong> (Sensors)。</p>
                        <p class="mb-2"><strong>大数据</strong>：是数据的<strong>矿藏</strong> (挖掘价值)。</p>
                        <p><strong>云计算</strong>：是数据的<strong>基础设施</strong> (提供存储/计算能力)。</p>
                    </div>
                    <p class="mt-2 text-sm text-slate-500">比喻：物联网是采集矿石，大数据是提炼黄金，云计算是冶炼厂。</p>` 
            },

            // --- 第3章 ---
            { 
                id: 8, ch: 'ch3', 
                q: "9. 大数据技术的不同层面及其功能 (5)", 
                a: `<ol class="list-decimal pl-5 space-y-2">
                        <li><strong>数据采集与预处理</strong>：利用ETL工具、<strong>网络爬虫</strong>等，将分布的、异构的数据源进行抽取、清洗。</li>
                        <li><strong>数据存储与管理</strong>：利用分布式文件系统(HDFS)、数据仓库、NoSQL数据库等存储海量数据。</li>
                        <li><strong>数据处理与分析</strong>：利用分布式并行编程模型(MapReduce)和计算框架(Spark)进行分析。</li>
                        <li><strong>数据可视化</strong>：将分析结果以图形化展示。</li>
                        <li><strong>数据应用</strong>：将结果应用于具体领域 (如推荐系统)。</li>
                    </ol>` 
            },
            { 
                id: 9, ch: 'ch3', 
                q: "10. 传统的数据采集与大数据采集的区别 (19)", 
                a: `<table class="content-table">
                        <thead><tr><th>对比项</th><th>传统数据采集</th><th>大数据采集</th></tr></thead>
                        <tbody>
                            <tr><td><strong>数据源</strong></td><td>单一 (主要是数据库)</td><td>广泛 (网络、传感器、日志)</td></tr>
                            <tr><td><strong>数据量</strong></td><td>较小</td><td>海量 (PB级)</td></tr>
                            <tr><td><strong>数据类型</strong></td><td>结构化数据为主</td><td>非结构化数据为主 (视频/图片)</td></tr>
                            <tr><td><strong>采集方法</strong></td><td>ETL工具</td><td>API接口、网络爬虫、传感器</td></tr>
                        </tbody>
                    </table>` 
            },
            { 
                id: 10, ch: 'ch3', 
                q: "11. 数据采集的 3 大要点 (20)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>全面性</strong>：采集的数据要尽可能全面，覆盖面广。</li>
                        <li><strong>多维性</strong>：从不同维度、不同角度采集数据 (如用户画像需包含人口属性、行为数据等)。</li>
                        <li><strong>高效性</strong>：采集速度要快，特别是实时数据采集 (如Kafka)。</li>
                    </ul>` 
            },
            { 
                id: 11, ch: 'ch3', 
                q: "12. 数据采集的数据源 (28 名字+分类型)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>开放数据</strong>：政府开放数据、科研数据、互联网公共数据。</li>
                        <li><strong>网络数据</strong>：社交媒体数据 (微博/微信)、电商数据、网页数据。</li>
                        <li><strong>感知数据</strong>：视频监控、传感器数据、GPS数据 (物联网)。</li>
                        <li><strong>企业数据</strong>：企业内部业务数据、服务器日志。</li>
                    </ul>` 
            },
            { 
                id: 12, ch: 'ch3', 
                q: "13. 数据采集方法 (39 名字+分类型)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>系统日志采集</strong>：使用 <span class="text-blue-600 font-bold">Flume</span> (分布式高可靠日志收集)。</li>
                        <li><strong>网络数据采集</strong>：使用 <span class="text-blue-600 font-bold">网络爬虫</span> (Crawler/八爪鱼)。</li>
                        <li><strong>数据库同步</strong>：使用 <span class="text-blue-600 font-bold">Sqoop/DataX</span> (ETL工具)。</li>
                        <li><strong>消息队列</strong>：使用 <span class="text-blue-600 font-bold">Kafka</span> (高吞吐量消息缓冲)。</li>
                    </ul>` 
            },
            { 
                id: 13, ch: 'ch3', 
                q: "14. 需要清洗的数据的主要类型 (53)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>残缺数据</strong> (Missing Data)：数据缺失。</li>
                        <li><strong>错误数据</strong> (Error Data)：数值超出范围或逻辑错误。</li>
                        <li><strong>重复数据</strong> (Duplicate Data)：多次记录。</li>
                        <li>数据格式不一致：日期格式混乱等。</li>
                    </ul>` 
            },
            { 
                id: 14, ch: 'ch3', 
                q: "15. 数据清洗的内容 (54 55)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>缺失值清洗</strong>：删除记录、插补 (均值/中位数填充)、不处理。</li>
                        <li><strong>格式内容清洗</strong>：时间、日期、数值格式统一。</li>
                        <li><strong>逻辑错误清洗</strong>：去重、去除不合理值 (如年龄200岁)。</li>
                        <li><strong>非需求数据清洗</strong>：删除不需要的字段。</li>
                    </ul>` 
            },
            { 
                id: 15, ch: 'ch3', 
                q: "16. 常见的数据转换策略 (69 名字+类型)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>平滑</strong>：去除噪声 (如分箱、回归、聚类)。</li>
                        <li><strong>聚集</strong>：对数据进行汇总 (如日销量->月销量)。</li>
                        <li><strong>概化</strong>：低层数据映射到高层 (如23岁->青年)。</li>
                        <li><strong>规范化</strong>：数据归一化到特定区间 (如0.0-1.0)。</li>
                        <li><strong>属性构造</strong>：根据现有属性构造新属性 (如根据身高体重计算BMI)。</li>
                    </ul>` 
            },
            { 
                id: 16, ch: 'ch3', 
                q: "17. 规范化 (Normalization) (79)", 
                a: `<p>将属性数据按比例缩放，使之落入一个小的特定区间。</p>
                    <ul class="list-disc pl-5 space-y-1 mt-2">
                        <li><strong>最小-最大规范化</strong>：线性变换，映射到 [0, 1]。</li>
                        <li><strong>零-均值规范化 (Z-Score)</strong>：基于均值和标准差，用于数值分布差异大的情况。</li>
                        <li><strong>小数定标规范化</strong>：移动小数点位置。</li>
                    </ul>` 
            },
            { 
                id: 17, ch: 'ch3', 
                q: "18. 数据脱敏的方法 (92 名字+例子)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>无效化</strong>：将敏感数据置空或用 * 代替。</li>
                        <li><strong>随机值</strong>：用随机生成的数据代替真值。</li>
                        <li><strong>数据替换</strong>：用虚拟值替换 (如把"张三"替换为"李四")。</li>
                        <li><strong>对称加密</strong>：使用加密算法 (AES/DES) 加密。</li>
                        <li><strong>平均值</strong>：针对数值型数据，用平均值代替。</li>
                        <li><strong>偏移和取整</strong>：数值微调。</li>
                    </ul>` 
            },

            // --- 第4章 ---
            { 
                id: 18, ch: 'ch4', 
                q: "19. 传统和大数据时代存储技术 (4+3)", 
                a: `<p class="font-bold text-slate-700">传统存储技术：</p>
                    <ul class="list-disc pl-5 mb-2">
                        <li><strong>DAS</strong> (直连式存储)：直接连在服务器上，扩展性差。</li>
                        <li><strong>NAS</strong> (网络附加存储)：通过局域网文件共享，性能受限。</li>
                        <li><strong>SAN</strong> (存储区域网络)：专用光纤网络，成本高。</li>
                    </ul>
                    <p class="font-bold text-slate-700">大数据存储技术：</p>
                    <ul class="list-disc pl-5">
                        <li><strong>分布式文件系统</strong> (如 HDFS)。</li>
                        <li><strong>NoSQL 数据库</strong> (如 HBase, MongoDB)。</li>
                        <li><strong>NewSQL 数据库</strong> (兼顾关系型与分布式)。</li>
                    </ul>` 
            },
            { 
                id: 19, ch: 'ch4', 
                q: "20. Hadoop 的特性 (47)", 
                a: `<ol class="list-decimal pl-5 space-y-1">
                        <li><strong>高可靠性</strong>：维护多个副本 (默认3个)。</li>
                        <li><strong>高高效性</strong>：并行计算，移动计算而非移动数据。</li>
                        <li><strong>高可扩展性</strong>：可方便地增加节点。</li>
                        <li><strong>高容错性</strong>：自动检测失败节点并恢复数据。</li>
                        <li><strong>成本低</strong>：运行在廉价的普通PC服务器上。</li>
                        <li><strong>运行在Linux上</strong>：跨平台性好。</li>
                        <li><strong>支持多种编程语言</strong>：Java, C++, Python等。</li>
                    </ol>` 
            },
            { 
                id: 20, ch: 'ch4', 
                q: "21. Hadoop 的发展历程和组件", 
                a: `<p><strong>发展历程：</strong></p>
                    <p>Hadoop 1.0 (HDFS + MapReduce) -> Hadoop 2.0 (增加了 YARN 资源调度)。</p>
                    <p class="mt-2 font-bold">核心组件 (三驾马车)：</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>HDFS</strong>：分布式文件系统 (存储)。</li>
                        <li><strong>MapReduce</strong>：分布式并行计算模型 (计算)。</li>
                        <li><strong>YARN</strong>：资源管理和调度器 (调度)。</li>
                        <li><strong>Common</strong>：通用工具模块。</li>
                    </ul>` 
            },
            { 
                id: 21, ch: 'ch4', 
                q: "22. HDFS 设计目标 (65)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>兼容廉价硬件</strong>：硬件故障是常态，需要自动容错。</li>
                        <li><strong>流式数据访问</strong>：一次写入，多次读取 (Write-Once-Read-Many)。</li>
                        <li><strong>处理大数据集</strong>：支持GB、TB甚至PB级文件。</li>
                        <li><strong>简单一致性模型</strong>：支持文件追加，不支持任意位置修改。</li>
                        <li><strong>移动计算比移动数据更经济</strong>。</li>
                    </ul>` 
            },
            { 
                id: 22, ch: 'ch4', 
                q: "23. HDFS 局限性 (66)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>不适合低延迟数据访问</strong>：HDFS 是为高吞吐量设计的，延迟较高 (秒级)。</li>
                        <li><strong>无法高效存储大量小文件</strong>：小文件会占用 NameNode 大量内存 (元数据)。</li>
                        <li><strong>不支持多用户写入及任意修改文件</strong>：仅支持单用户追加写 (Append)。</li>
                    </ul>` 
            },
            { 
                id: 23, ch: 'ch4', 
                q: "24. HDFS 体系结构 (68-70)", 
                a: `<p>采用 <strong>Master/Slave (主从)</strong> 结构：</p>
                    <ul class="list-disc pl-5 space-y-2 mt-2">
                        <li><strong>NameNode (主)</strong>：管理者。<br>负责管理文件系统的命名空间 (Namespace)，维护文件目录树，记录文件分块信息 (Metadata)，处理客户端请求。</li>
                        <li><strong>DataNode (从)</strong>：工作者。<br>负责存储实际的数据块 (Block)，执行读写操作，定期向 NameNode 汇报状态。</li>
                        <li><strong>SecondaryNameNode</strong>：<br>辅助节点，定期合并 Fsimage 和 Edits 日志，减少 NameNode 重启时间。<span class="text-red-600 font-bold">注意：它不是 NameNode 的热备。</span></li>
                    </ul>` 
            },
            { 
                id: 24, ch: 'ch4', 
                q: "25. HDFS 读、写操作原理 (重点大题 71-87)", 
                a: `
                    <div class="mb-4">
                        <span class="font-bold text-blue-700 block mb-1">【写数据流程】 (关键：Pipeline, Ack)</span>
                        <ol class="list-decimal pl-5 text-sm space-y-1">
                            <li>客户端向 NameNode 请求上传文件。</li>
                            <li>NameNode 检查权限和目录，返回允许上传的 DataNode 列表 (如 A, B, C)。</li>
                            <li>客户端将文件切分为 Block，进一步切分为 Packet。</li>
                            <li>客户端与 DataNode 建立 <strong>Pipeline (数据管道)</strong> (Client -> A -> B -> C)。</li>
                            <li>数据通过管道流式传输。</li>
                            <li>DataNode 返回 <strong>Ack (确认)</strong> 包 (C -> B -> A -> Client)。</li>
                            <li>传输完成，通知 NameNode。</li>
                        </ol>
                    </div>
                    <div>
                        <span class="font-bold text-green-700 block mb-1">【读数据流程】 (关键：机架感知)</span>
                        <ol class="list-decimal pl-5 text-sm space-y-1">
                            <li>客户端向 NameNode 请求下载文件。</li>
                            <li>NameNode 查询元数据，返回文件 Block 所在的 DataNode 地址列表。</li>
                            <li><strong>机架感知 (Rack Awareness)</strong>：NameNode 会按距离客户端的远近排序 (就近原则)。</li>
                            <li>客户端直接连接最近的 DataNode 读取数据。</li>
                            <li>读取完成后关闭连接。</li>
                        </ol>
                    </div>` 
            },
            { 
                id: 25, ch: 'ch4', 
                q: "26. NoSQL 数据库的类型及优势 (89/29-31)", 
                a: `<table class="content-table">
                        <thead><tr><th>类型</th><th>代表产品</th><th>典型应用</th></tr></thead>
                        <tbody>
                            <tr><td><strong>键值数据库</strong></td><td>Redis, Memcached</td><td>缓存、会话管理 (快)</td></tr>
                            <tr><td><strong>列族数据库</strong></td><td>HBase, Cassandra</td><td>海量数据、分布式存储</td></tr>
                            <tr><td><strong>文档数据库</strong></td><td>MongoDB</td><td>Web应用、内容管理 (灵活)</td></tr>
                            <tr><td><strong>图数据库</strong></td><td>Neo4j</td><td>社交网络、推荐系统 (关系)</td></tr>
                        </tbody>
                    </table>
                    <p class="mt-2 font-bold">NoSQL 的优势：</p>
                    <ul class="list-disc pl-5 text-sm">
                        <li>灵活的可扩展性 (横向扩展)。</li>
                        <li>灵活的数据模型 (Schema-free)。</li>
                        <li>与云计算紧密融合。</li>
                        <li>大数据处理能力强。</li>
                    </ul>` 
            },
            { 
                id: 26, ch: 'ch4', 
                q: "27. 云数据库的特性 (104)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>动态可扩展</strong>：根据业务需求自动伸缩。</li>
                        <li><strong>高可用性</strong>：自动备份容灾，故障自动切换。</li>
                        <li><strong>较低的使用成本</strong>：按需付费，无需购买硬件。</li>
                        <li><strong>易用性</strong>：提供 Web 管理界面，开箱即用。</li>
                        <li><strong>高性能</strong>：针对云环境优化。</li>
                        <li><strong>免维护</strong>：无需专门 DBA 维护底层。</li>
                        <li><strong>安全</strong>：提供专业的安全防护。</li>
                    </ul>` 
            },

            // --- 第5章 ---
            { 
                id: 27, ch: 'ch5', 
                q: "28. 狭义数据分析、广义数据分析 (5)", 
                a: `<p><strong>狭义数据分析</strong>：<br>侧重于使用统计学方法，对历史数据进行描述性分析。回答“<strong>过去发生了什么</strong>”。</p>
                    <p class="mt-2"><strong>广义数据分析</strong>：<br>包括数据挖掘和机器学习。侧重于从数据中发现隐含模式，进行预测性分析。回答“<strong>未来可能发生什么</strong>”。</p>` 
            },
            { 
                id: 28, ch: 'ch5', 
                q: "29. 协同过滤的类型 (31)", 
                a: `<ul class="list-disc pl-5 space-y-2">
                        <li><strong>基于用户的协同过滤 (User-based)</strong>：<br>原理：你和 A 兴趣相似，A 喜欢 X，所以推荐 X 给你。<br>场景：发现热点，新闻推荐。</li>
                        <li><strong>基于物品的协同过滤 (Item-based)</strong>：<br>原理：你喜欢 A，A 和 B 相似，所以推荐 B 给你。<br>场景：电商推荐 (买了尿布推荐啤酒)，长尾物品推荐。</li>
                    </ul>` 
            },
            { 
                id: 29, ch: 'ch5', 
                q: "30. 大数据处理与分析技术分类 (38)", 
                a: `<table class="content-table">
                        <thead><tr><th>分类</th><th>解决问题</th><th>代表产品</th></tr></thead>
                        <tbody>
                            <tr><td><strong>批处理计算</strong></td><td>大规模离线数据处理</td><td>MapReduce, Spark</td></tr>
                            <tr><td><strong>流计算</strong></td><td>实时数据处理</td><td>Flink, Storm, Spark Streaming</td></tr>
                            <tr><td><strong>图计算</strong></td><td>图结构/关系数据分析</td><td>GraphX, Neo4j</td></tr>
                            <tr><td><strong>查询分析计算</strong></td><td>类似SQL的交互式查询</td><td>Hive, Impala, Spark SQL</td></tr>
                        </tbody>
                    </table>` 
            },
            { 
                id: 30, ch: 'ch5', 
                q: "31. 流计算流程、特点及场景 (43/39)", 
                a: `<p class="font-bold">流程：</p>
                    <p>数据采集 (Flume/Kafka) -> 数据摄入 -> 流处理 (Flink/Storm) -> 存储/展示。</p>
                    <p class="font-bold mt-2">特点：</p>
                    <ul class="list-disc pl-5">
                        <li><strong>实时性</strong>：秒级或毫秒级延迟。</li>
                        <li><strong>无界性</strong>：数据源源不断。</li>
                        <li><strong>连续性</strong>：计算持续进行。</li>
                    </ul>
                    <p class="font-bold mt-2">适用场景：</p>
                    <p>实时监控、金融风控、交通拥堵分析、实时推荐。</p>` 
            },
            { 
                id: 31, ch: 'ch5', 
                q: "32. 流处理 vs 传统数据处理 (53)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>数据状态</strong>：流处理是动态数据流；传统是静态数据库。</li>
                        <li><strong>处理方式</strong>：流处理是持续计算；传统是一次性查询。</li>
                        <li><strong>触发方式</strong>：流处理是数据驱动 (主动推送)；传统是用户查询 (被动拉取)。</li>
                        <li><strong>结果</strong>：流处理结果随时间更新；传统结果固定。</li>
                    </ul>` 
            },
            { 
                id: 32, ch: 'ch5', 
                q: "33. MapReduce 的基本理论和工作流程 (56-66)", 
                a: `<p><strong>基本理论：</strong>“分而治之” (Divide and Conquer)。把大任务拆分成小任务并行处理，最后合并结果。</p>
                    <p class="mt-2 font-bold">工作流程 (Split -> Map -> Shuffle -> Reduce)：</p>
                    <ol class="list-decimal pl-5 space-y-1">
                        <li><strong>Split (切片)</strong>：将输入数据切分为若干分片。</li>
                        <li><strong>Map (映射)</strong>：各节点并行处理分片，输出 &lt;Key, Value&gt;。</li>
                        <li><strong class="text-red-600">Shuffle (洗牌)</strong>：核心阶段。包括分区(Partition)、排序(Sort)、合并(Combine)、溢写(Spill)、拉取(Fetch)。将相同的 Key 发送到同一个 Reduce。</li>
                        <li><strong>Reduce (归约)</strong>：汇总相同 Key 的数据，输出最终结果。</li>
                    </ol>` 
            },
            { 
                id: 33, ch: 'ch5', 
                q: "34. MapReduce 的缺点 (74-78)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>表达能力有限</strong>：仅支持 Map 和 Reduce 两个算子，复杂逻辑需串联多个 Job。</li>
                        <li><strong>磁盘 I/O 开销大</strong>：中间结果必须写入磁盘，导致频繁读写。</li>
                        <li><strong>延迟高</strong>：只适合离线批处理，不适合实时计算。</li>
                        <li><strong>不适合迭代计算</strong>：如机器学习算法，每次迭代都要读写磁盘。</li>
                    </ul>` 
            },
            { 
                id: 34, ch: 'ch5', 
                q: "35. Spark 的特点 (85)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>运行速度快</strong>：基于<strong>内存计算</strong>，比 MapReduce 快 10-100 倍。</li>
                        <li><strong>易用性</strong>：支持 Java, Scala, Python, R；提供丰富 API。</li>
                        <li><strong>通用性</strong>：(One Stack to rule them all) 统一支持批处理、流处理、SQL、机器学习、图计算。</li>
                        <li><strong>运行模式多样</strong>：可运行在 YARN, Mesos, Standalone 上。</li>
                    </ul>` 
            },
            { 
                id: 35, ch: 'ch5', 
                q: "36. Spark 相比于 MapReduce 的优点 (86)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>速度</strong>：Spark 基于内存，MapReduce 基于磁盘。</li>
                        <li><strong>调度</strong>：Spark 基于 DAG (有向无环图) 的任务调度，比 MapReduce 的线性流程更优化。</li>
                        <li><strong>容错</strong>：Spark 基于 RDD (弹性分布式数据集) 的血统机制 (Lineage) 进行容错。</li>
                        <li><strong>适用性</strong>：Spark 更适合<strong>迭代计算</strong> (数据挖掘/机器学习) 和交互式查询。</li>
                    </ul>` 
            },
            { 
                id: 36, ch: 'ch5', 
                q: "37. Spark 系统的组件 (92)", 
                a: `<table class="content-table">
                        <thead><tr><th>组件名称</th><th>功能</th><th>对应其他框架</th></tr></thead>
                        <tbody>
                            <tr><td><strong>Spark Core</strong></td><td>核心计算引擎</td><td>MapReduce</td></tr>
                            <tr><td><strong>Spark SQL</strong></td><td>结构化数据处理</td><td>Hive</td></tr>
                            <tr><td><strong>Spark Streaming</strong></td><td>流式计算 (微批)</td><td>Storm</td></tr>
                            <tr><td><strong>MLlib</strong></td><td>机器学习库</td><td>Mahout</td></tr>
                            <tr><td><strong>GraphX</strong></td><td>图计算</td><td>Pregel</td></tr>
                        </tbody>
                    </table>` 
            },
            { 
                id: 37, ch: 'ch5', 
                q: "38. Spark 和 Hadoop MapReduce 的关系 (书221)", 
                a: `<p><strong>关系：</strong></p>
                    <ul class="list-disc pl-5 mb-2">
                        <li>Spark 是 MapReduce 的<strong>替代者</strong>或<strong>继承者</strong> (在计算层面)。</li>
                        <li>Spark 并不是要取代 Hadoop，而是兼容 Hadoop 生态。</li>
                    </ul>
                    <p><strong>互补共存：</strong></p>
                    <p>通常 Spark 运行在 Hadoop <strong>YARN</strong> (资源调度) 之上，并使用 <strong>HDFS</strong> (数据存储) 存储数据。Spark 负责“算”，Hadoop 负责“存”和“管”。</p>` 
            },
            { 
                id: 38, ch: 'ch5', 
                q: "39. Flink 的优势 (108)", 
                a: `<ul class="list-disc pl-5 space-y-1">
                        <li><strong>Native Streaming (原生流处理)</strong>：不同于 Spark 的微批处理，延迟更低。</li>
                        <li><strong>高性能</strong>：高吞吐、低延迟。</li>
                        <li><strong>支持 Exactly-once 语义</strong>：确保数据不丢不重，结果精确。</li>
                        <li><strong>批流一体</strong>：一套代码同时支持流处理和批处理。</li>
                        <li><strong>支持有状态计算</strong>。</li>
                    </ul>` 
            },
            { 
                id: 39, ch: 'ch5', 
                q: "40. Spark Streaming, Storm, Flink 比较 (106/107)", 
                a: `<table class="content-table">
                        <thead><tr><th>特性</th><th>Storm</th><th>Spark Streaming</th><th>Flink</th></tr></thead>
                        <tbody>
                            <tr><td><strong>处理模型</strong></td><td>纯流式 (单条)</td><td>微批处理 (Micro-batch)</td><td>纯流式 + 批处理</td></tr>
                            <tr><td><strong>延迟</strong></td><td>极低 (毫秒级)</td><td>秒级</td><td>极低 (毫秒级)</td></tr>
                            <tr><td><strong>吞吐量</strong></td><td>低</td><td>高</td><td>高</td></tr>
                            <tr><td><strong>一致性</strong></td><td>At-least-once</td><td>Exactly-once</td><td>Exactly-once</td></tr>
                        </tbody>
                    </table>` 
            }
        ];

        // === 逻辑代码 ===
        const list = document.getElementById('list');
        const scoreEl = document.getElementById('score');
        const progressEl = document.getElementById('progress');
        
        // 读取本地存储
        let memorized = new Set(JSON.parse(localStorage.getItem('bd_full_review_done') || '[]'));

        function init() {
            renderList('all');
            updateStats();
        }

        function renderList(filterCh) {
            list.innerHTML = '';
            points.forEach(p => {
                if (filterCh !== 'all' && p.ch !== filterCh) return;
                
                const isDone = memorized.has(p.id);
                
                const div = document.createElement('div');
                div.className = `bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden ${isDone ? 'card-memorized' : ''}`;
                
                div.innerHTML = `
                    <div class="p-4 flex items-start gap-3 cursor-pointer select-none" onclick="toggleAnswer(this)">
                        <div class="mt-1 shrink-0" onclick="event.stopPropagation(); toggleDone(${p.id}, this)">
                            <div class="check-circle w-6 h-6 rounded-full border-2 flex items-center justify-center ${isDone ? 'bg-green-500 border-green-500 text-white' : 'border-slate-300 hover:border-blue-400 text-transparent'}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                            </div>
                        </div>
                        <div class="flex-1">
                            <div class="mb-1">
                                <span class="tag tag-${p.ch}">${getChName(p.ch)}</span>
                            </div>
                            <h3 class="text-base font-medium text-slate-800 leading-snug">${p.q}</h3>
                        </div>
                        <span class="text-slate-300 text-xs mt-1">▼</span>
                    </div>
                    <!-- 答案区域 -->
                    <div class="answer-box border-t border-slate-100 text-sm text-slate-700 leading-relaxed">
                        ${p.a}
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function toggleAnswer(el) {
            const box = el.nextElementSibling;
            const isOpen = box.classList.contains('open');
            if (isOpen) {
                box.classList.remove('open');
                el.querySelector('span:last-child').style.transform = 'rotate(0deg)';
            } else {
                box.classList.add('open');
                el.querySelector('span:last-child').style.transform = 'rotate(180deg)';
            }
        }

        function toggleDone(id, btn) {
            const card = btn.closest('.bg-white');
            const circle = btn.querySelector('.check-circle');
            
            if (memorized.has(id)) {
                memorized.delete(id);
                card.classList.remove('card-memorized');
                circle.className = "check-circle w-6 h-6 rounded-full border-2 flex items-center justify-center border-slate-300 hover:border-blue-400 text-transparent";
            } else {
                memorized.add(id);
                card.classList.add('card-memorized');
                circle.className = "check-circle w-6 h-6 rounded-full border-2 flex items-center justify-center bg-green-500 border-green-500 text-white";
            }
            localStorage.setItem('bd_full_review_done', JSON.stringify([...memorized]));
            updateStats();
        }

        function updateStats() {
            const count = memorized.size;
            scoreEl.innerText = `${count}/40`;
            progressEl.style.width = `${(count / 40) * 100}%`;
            if(count === 40) progressEl.classList.replace('bg-blue-600', 'bg-green-500');
        }

        function filter(ch) {
            renderList(ch);
        }

        function reset() {
            if(confirm('确定重置所有进度吗？')) {
                memorized.clear();
                localStorage.removeItem('bd_full_review_done');
                init();
            }
        }

        function expandAll() {
            document.querySelectorAll('.answer-box').forEach(b => b.classList.add('open'));
        }

        function getChName(ch) {
            const map = {ch1: '第1章', ch2: '第2章', ch3: '第3章', ch4: '第4章', ch5: '第5章'};
            return map[ch];
        }

        init();
    </script>
</body>
</html>